<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">


  <style>

    .b ul{
      color: cornsilk;
      font-size: 17px;
      font-family: 'Times New Roman', Times, serif;
      background-color: rgb(8, 88, 88);
      padding: 30px;
      border: 3px solid #06fa06;

    }
  
    .img1{
  float: left;
  
}


 /* Responsive layout - makes the three columns stack on top of each other instead of next to each other */
@media screen and (max-width:600px) {
 .navbar a{
   width: 100%;
 }
}
  </style>

  <title>Pablo Acuna's assignments</title>
</head>
<body>

  <div class="img1">
    <a href="../index.html">
    <img src="home_logo.png" alt= "home_logo"> </a>
    </div>

<div class="h1">
<a href="assign10.html">

</a> 
<h1>Welcome to Week 10</h1>
</div>

<div class="navbar">
    
        <a href="./ninja.html">Ninja Quiz Invoking the shuffle function</a>
        
</div>


 <h2>Notes</h2>

 
 
 <div class = "b">
   <h3>Client-side Form Validation</h3>
 <ul >

    <li>Before submitting data to the server, it is important to ensure all required form controls are filled out, in the correct format.</li>
    <li>This is called client-side form validation, and helps ensure data submitted matches the requirements set forth in the various form controls.   </li>
    <li>Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away.   </li>
    <li>Client-side validation should not be considered an exhaustive security measure!  </li>
    <li>Apps should always perform security checks on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to bypass, so malicious users can still easily send bad data through to your server.  </li>
    <li>When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application. This is called form validation.  </li>
    <li>Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation.  </li>
    <li>Three reasons to use validation in our forms: We want to get the right data, in the right format, we want to protect our users' data, and we want to protect ourselves.  </li>
    <li>Two different types of client-side validation features: Built-in form validation, and JavaScript.  </li>
    <li>One of the most significant features of HTML5 form controls is the ability to validate most user data without relying on JavaScript.  </li>
    <li>Another useful validation feature is the pattern attribute, which expects a Regular Expression as its value. A regular expression (regex) is a pattern that can be used to match character combinations in text strings, so reg expression are ideal for form validation and serve a variety of other uses in JavaScript.  </li>
    <li>The constraint validation API gives you a powerful tool to handle form validation, letting you have enormous control over the user interface above and beyond what you can do with HTML and CSS alone.  </li>

 </ul>
</div>


<div class = "b">
    <h3>Using Fetch</h3>
  <ul >

  <li>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.  </li>
  <li>Fetch provides a better alternative that can be easily used by other technologies such as Service Workers.  </li>
  <li>Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP.  </li>
  <li>The fetch () method can optionally accept a second parameter, an init object that allows you to control a number of different settings.  </li>
  <li>To cause browsers to send a request with credentials included on both same-origin and cross-origin calls, add credentials: 'include' to the init object you pass to the fetch() method.  </li>
  <li>If you only want to send credentials if the request URL is on the same origin as the calling script, add credentials: 'same-origin'.  </li>
  <li>Files can be uploaded using an HTML input type="file" input element, FormData() and fetch().  </li>
  <li>Files can be uploaded using an HTML input type="file" multiple  input element, FormData() and fetch().  </li>
  <li>An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true.  </li>
  <li>Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method argument.  </li>
  <li>Response instances are returned when fetch() promises are resolved.  </li>
  <li>Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope.  </li>

  </ul>
</div>


</body>
</html>
